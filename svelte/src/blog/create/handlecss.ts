import expand_ from "css-shorthand-expand";
const expand = (propname: string, propval: string) =>
  expand_(propname, propval) ?? Object.fromEntries([[propname, propval]]);
// var expand = require("css-shorthand-expand");

// The list was automatically generated by going to https://www.w3.org/TR/2018/WD-css-logical-1-20180827/
//  and running the following commented-out code.

// // Get all the property definitions,
// // go to the <p> tag that follows the table,
// // and find all property definitions in the first sentence (before the first period).

// const propdefs = document.querySelectorAll('[id^="propdef-"]');
// const getFollowingP = (el: Element) => el.parentElement?.parentElement?.parentElement?.parentElement?.nextElementSibling
// Array(...propdefs).map((propdef) => [
//   propdef.id.slice("propdef-".length),
//   Array(
//     ...getFollowingP(propdef)!.querySelectorAll(
//       '[href*="#propdef-"]',
//     ),
//   )
//     .filter(
//       (el) =>
//         getFollowingP(propdef)!.textContent!.indexOf(
//           el.textContent!,
//         ) <
//         getFollowingP(propdef)!.textContent!.indexOf(
//           ".",
//         ),
//     )
//     .map((el) => el.textContent),
// ]);

type LogicalPropsMaps = [name: string, props: string[]][];
// prettier-ignore
const logicalPropsMaps_: LogicalPropsMaps = [
  ["block-size", ["width", "height"]],
  ["inline-size", ["width", "height"]],
  ["min-block-size", ["min-width", "min-height"]],
  ["min-inline-size", ["min-width", "min-height"]],
  ["max-block-size", ["max-width", "max-height"]],
  ["max-inline-size", ["max-width", "max-height"]],
  ["margin-block-start", ["margin-top", "margin-bottom", "margin-left", "margin-right"]],
  ["margin-block-end", ["margin-top", "margin-bottom", "margin-left", "margin-right"]],
  ["margin-inline-start", ["margin-top", "margin-bottom", "margin-left", "margin-right"]],
  ["margin-inline-end", ["margin-top", "margin-bottom", "margin-left", "margin-right"]],
  ["margin-block", ["margin-block-start", "margin-block-end"]],
  ["margin-inline", ["margin-inline-start", "margin-inline-end"]],
  ["inset-block-start", ["top", "bottom", "left", "right"]],
  ["inset-block-end", ["top", "bottom", "left", "right"]],
  ["inset-inline-start", ["top", "bottom", "left", "right"]],
  ["inset-inline-end", ["top", "bottom", "left", "right"]],
  ["inset-block", ["inset-block-start", "inset-block-end"]],
  ["inset-inline", ["inset-inline-start", "inset-inline-end"]],
  ["inset", ["top", "right", "bottom", "left"]],
  ["padding-block-start", ["padding-top", "padding-bottom", "padding-left", "padding-right"]],
  ["padding-block-end", ["padding-top", "padding-bottom", "padding-left", "padding-right"]],
  ["padding-inline-start", ["padding-top", "padding-bottom", "padding-left", "padding-right"]],
  ["padding-inline-end", ["padding-top", "padding-bottom", "padding-left", "padding-right"]],
  ["padding-block", ["padding-block-start", "padding-block-end"]],
  ["padding-inline", ["padding-inline-start", "padding-inline-end"]],
  ["border-block-start-width", ["border-top-width", "border-bottom-width", "border-left-width", "border-right-width"]],
  ["border-block-end-width", ["border-top-width", "border-bottom-width", "border-left-width", "border-right-width"]],
  ["border-inline-start-width", ["border-top-width", "border-bottom-width", "border-left-width", "border-right-width"]],
  ["border-inline-end-width", ["border-top-width", "border-bottom-width", "border-left-width", "border-right-width"]],
  ["border-block-width", ["border-block-start-width", "border-block-end-width"]],
  ["border-inline-width", ["border-inline-start-width", "border-inline-end-width"]],
  ["border-block-start-style", ["border-top-style", "border-bottom-style", "border-left-style", "border-right-style"]],
  ["border-block-end-style", ["border-top-style", "border-bottom-style", "border-left-style", "border-right-style"]],
  ["border-inline-start-style", ["border-top-style", "border-bottom-style", "border-left-style", "border-right-style"]],
  ["border-inline-end-style", ["border-top-style", "border-bottom-style", "border-left-style", "border-right-style"]],
  ["border-block-style", ["border-block-start-style", "border-block-end-style"]],
  ["border-inline-style", ["border-inline-start-style", "border-inline-end-style"]],
  ["border-block-start-color", ["border-top-color", "border-bottom-color", "border-left-color", "border-right-color"]],
  ["border-block-end-color", ["border-top-color", "border-bottom-color", "border-left-color", "border-right-color"]],
  ["border-inline-start-color", ["border-top-color", "border-bottom-color", "border-left-color", "border-right-color"]],
  ["border-inline-end-color", ["border-top-color", "border-bottom-color", "border-left-color", "border-right-color"]],
  ["border-block-color", ["border-block-start-color", "border-block-end-color"]],
  ["border-inline-color", ["border-inline-start-color", "border-inline-end-color"]],
  ["border-block-start", ["border-top", "border-bottom", "border-left", "border-right"]],
  ["border-block-end", ["border-top", "border-bottom", "border-left", "border-right"]],
  ["border-inline-start", ["border-top", "border-bottom", "border-left", "border-right"]],
  ["border-inline-end", ["border-top", "border-bottom", "border-left", "border-right"]],
  ["border-block", [ "border-block-start", "border-block-end"]],
  ["border-inline", ["border-inline-start", "border-inline-end"]],
  ["border-start-start-radius", ["border-top-left-radius", "border-bottom-left-radius", "border-top-right-radius", "border-bottom-right-radius"]],
  ["border-start-end-radius", ["border-top-left-radius", "border-bottom-left-radius", "border-top-right-radius", "border-bottom-right-radius"]],
  ["border-end-start-radius", ["border-top-left-radius", "border-bottom-left-radius", "border-top-right-radius", "border-bottom-right-radius"]],
  ["border-end-end-radius", ["border-top-left-radius", "border-bottom-left-radius", "border-top-right-radius", "border-bottom-right-radius"]],
];

// Recursively expands a prop name into a flat list of prop names that don't appear in the map as keys
const expandProp = (
  logicalPropsMaps: LogicalPropsMaps,
  prop: string,
): string | string[] => {
  const mapFind = logicalPropsMaps.find((map) => map[0] === prop);
  if (!mapFind) return prop;
  const newProps = mapFind[1].map((newProp) =>
    expandProp(logicalPropsMaps, newProp),
  );
  return newProps.flat(1);
};

function expandLogicalProps(logicalPropsMaps: LogicalPropsMaps) {
  const final: LogicalPropsMaps = [];
  for (const prop of logicalPropsMaps) {
    const expanded = expandProp(logicalPropsMaps, prop[0]);
    const expandedLst = typeof expanded === "object" ? expanded : [expanded];
    // Remove duplicates from expandedLst
    final.push([prop[0], Array(...new Set(expandedLst))]);
  }
  return final;
}

const logicalPropsMaps = expandLogicalProps(logicalPropsMaps_);
console.log(expand("margin-bottom", "10px"));

function specificityGreater(spec1: Specificity, spec2: Specificity) {
  return spec1.reduce(
    (p, c, i) => {
      if (p === null) {
        if (c > spec2[i]) return true;
        else if (c < spec2[i]) return false;
        // The specificities are equal
        return null;
      } else return p;
    },
    null as null | boolean,
  );
}
console.log(specificityGreater([1, 1, 0, 0], [1, 0, 0, 0]));

// A logical property has a certain list of physical properties it can map to,
//  and if all those properties are already set with higher precedence then it should
//  be considered inactive.
function handleLogicalProps(rules: PropsList) {
  const rules_ = rules.flatMap((rule) => {
    const expanded = Object.entries(expand(rule[0], rule[1].value));
    return expanded.map((el) => [
      el[0],
      {
        value: el[1],
        status: rule[1].status,
        specificity: rule[1].specificity,
      },
    ]);
  }) as PropsList;

  const blacklist: string[] = [];
  for (const [baseI, baseRule] of rules_.entries()) {
    const logicalMapEntry = logicalPropsMaps.find(
      (el) => baseRule[0] === el[0],
    );
    if (!logicalMapEntry) continue;
    const logicalMap = [...logicalMapEntry[1]];

    for (const [i, rule] of rules_.entries()) {
      const considered =
        specificityGreater(rule[1].specificity, baseRule[1].specificity) ??
        i > baseI;
      if (!considered) continue;
      const id = logicalMap.indexOf(rule[0]);
      if (id === -1) continue;
      logicalMap.splice(id, 1);
      if (logicalMap.length === 0) break;
    }
    if (logicalMap.length === 0) blacklist.push(baseRule[0]);
  }
  return rules.filter((el) => !blacklist.includes(el[0]));
}

type Specificity = CSSRule_["specificity"];
type PropsList = [
  string,
  { value: string; status: string; specificity: Specificity },
][];

export function getCSSProps(el: Element) {
  let rules = CSSUtilities.getCSSRules(el);

  // 1) Do not consider a rule or its properties if it was inherited, or applies to every element.

  rules = rules.filter(
    (rule) => rule.inheritance.length === 0 && !rule.selector.includes("*, "),
  );

  let propsList = rules.flatMap((rule) => {
    const props: [
      string,
      { value: string; status: string; specificity?: Specificity },
    ][] = Object.entries(rule.properties);
    props.forEach((prop) => (prop[1].specificity = rule.specificity));
    return props;
  }) as PropsList;

  // 2) Only consider a property if it is active

  propsList = propsList.filter((prop) => prop[1].status === "active");
  propsList = handleLogicalProps(propsList);

  // 3) Remove 'unicode-bidi' and 'direction' because it 'should not be overridden by web designers'

  propsList = propsList.filter(
    (prop) => prop[0] !== "unicode-bidi" && prop[0] !== "direction",
  );

  // 4) Remove properties if their value is a CSS-wide value

  const cssWideVals = ["initial", "inherit", "unset", "revert", "revert-layer"];
  propsList = propsList.filter((prop) => !cssWideVals.includes(prop[1].value));

  const props: [k: string, v: string][] = propsList.map((prop) => [
    prop[0],
    prop[1].value,
  ]);
  return props;
}

const splitOn = (str: string, ...indices: number[]) =>
  [-1, ...indices].map((n, i, m) => str.slice(n + 1, m[i + 1]));

// Splits a string 'str' by a character 'char', like str.split(char),
//  but it ignore 'char's that are escaped by a backslash, or are
//  inside a quoted string, in single (') or double ("") quotes.
export function splitStringAtChar(str: string, char: string) {
  const getMatchRanges = (regex: RegExp) =>
    [...str.matchAll(regex)].map((exp) => [
      exp.index,
      exp.index + exp[0].length,
    ]);
  const dQuoteRanges = getMatchRanges(/"([^"\\]|\\.)*"/g);
  const sQuoteRanges = getMatchRanges(/'([^'\\]|\\.)*'/g);
  const allRanges = [...dQuoteRanges, ...sQuoteRanges];

  const regex = new RegExp("(?<!\\\\)" + char, "g");
  // Find all matches for unescaped 'char' and filter out the ones that
  //  fall within the quoted string ranges.
  const splitIndices = [...str.matchAll(regex)]
    .filter(
      (exp) =>
        !allRanges.some(
          (range) => exp.index > range[0] && exp.index < range[1],
        ),
    )
    .map((exp) => exp.index);
  const split = splitOn(str, ...splitIndices);
  // if (!split.at(-1)) split.splice(-1, 1);
  return split;
}

const STR = 'con\\;tent: "boo; yah";hello: world;';
console.log(STR, splitStringAtChar(STR, ";"));
