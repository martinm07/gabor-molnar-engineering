import { closest, prevSibling, sortNodesInDocumentOrder } from "./helper";
import { fetch_ } from "/shared/helper";

export type DocNodeMap = Map<
  Node,
  | {
      stringPos: number;
      stringLen: number;
      parentList: Element[];
      isEl: true;
      startTagLen: number;
    }
  | { stringPos: number; stringLen: number; parentList: Element[]; isEl: false }
>;

export type DocPatch = {
  value: string;
  start: number;
  length: number;
};

// Generated by Claude
export function getNodeSourceRepresentation(node: Node): string {
  switch (node.nodeType) {
    case Node.ELEMENT_NODE:
      return (node as Element).outerHTML;
    case Node.TEXT_NODE:
      return node.textContent ?? "";
    case Node.COMMENT_NODE:
      return `<!--${node.textContent}-->`;
    case Node.DOCUMENT_TYPE_NODE:
      return new XMLSerializer().serializeToString(node);
    case Node.PROCESSING_INSTRUCTION_NODE:
      return `<?${(node as ProcessingInstruction).target} ${(node as ProcessingInstruction).data}?>`;
    case Node.CDATA_SECTION_NODE:
      return `<![CDATA[${(node as CDATASection).data}]]>`;
    case Node.DOCUMENT_FRAGMENT_NODE:
      return Array.from(node.childNodes)
        .map(getNodeSourceRepresentation)
        .join("");
    case Node.DOCUMENT_NODE:
      return new XMLSerializer().serializeToString(node);
    default:
      return "";
  }
}

function getElementString(
  el: Element,
): [startingTag: string, closingTag: string | null] {
  const nodeStr = el.outerHTML;

  const closingTagStr = `</${el.tagName.toLowerCase()}>`;
  // Check if this is a void element (e.g. '<img />')
  if (!nodeStr.endsWith(closingTagStr)) {
    return [nodeStr, null];
  } else {
    const startingTagStr = nodeStr.slice(
      0,
      nodeStr.length - el.innerHTML.length - closingTagStr.length,
    );
    return [startingTagStr, closingTagStr];
  }
}

/**
 * Reconstructs the HTML string representation of a given container element and maps each DOM node
 * to its corresponding position and length within the resulting string.
 *
 * Traverses the DOM tree rooted at `containerEl` using a `TreeWalker`, reconstructing the HTML
 * source as a string while tracking the string positions and lengths of each node. The function
 * also handles nested elements and their closing tags, ensuring accurate mapping for both elements
 * and text nodes.
 *
 * @param containerEl - The root DOM element whose HTML string representation is to be reconstructed.
 * @param includeContainer - If true, includes the container element's tags in the output string and mapping.
 * @param docNodes - (Optional) An existing map to populate with node location data. If not provided, a new map is created.
 * @returns A tuple containing:
 *   - `nodeLocs`: A map associating each DOM node with its string position, length, and additional metadata.
 *   - `finalStr`: The reconstructed HTML string representation of the container element.
 */
export function reconstructHTMLStr(
  containerEl: Element,
  includeContainer: boolean = false,
  startingStringIndex: number = 0,
  docNodes?: DocNodeMap,
  topEl?: Element,
): [nodeLocs: DocNodeMap, finalStr: string] {
  docNodes ??= new Map();

  // This shouldn't be necessary
  containerEl.normalize();

  const walker = document.createTreeWalker(containerEl, NodeFilter.SHOW_ALL);

  let stringIndex: number = startingStringIndex;
  let constructedHTMLString: string = "";

  const getNextNode = () => {
    if (includeContainer) {
      includeContainer = false;
      return walker.currentNode;
    } else return walker.nextNode();
  };

  const parentClosingTags: {
    el: Element;
    startingTag: string;
    closingTag: string;
    index: number;
    length: number;
  }[] = [];
  while (getNextNode()) {
    const node = walker.currentNode;
    // console.log(node);
    const nodeStr = getNodeSourceRepresentation(node);

    // Because of the order in which nodes are explored, when first coming across an element,
    //  we explore all the children of that element *first*, and the first thing that is explored
    //  *after* we have explored all the children is the next sibling of that element.
    // Note, that multiple elements may be closed at the same time e.g. <p>Hello <em>world</em></p><div></div>
    //  would have the parentClosingTags stack of [p, em] at <div>, whose previousSibling is <p>, not <em>
    //  Hence, we have to search the entire stack for matches, not just checking the top element of the stack
    const topClosedParentIndex = parentClosingTags.findLastIndex(
      ({ el }) => node.previousSibling === el,
    );
    if (topClosedParentIndex !== -1) {
      // Must keep this evaluation outside of the loop expression, which reevaluates every iteration
      //  - and the length of parentClosingTags changes as we pop elements
      const numIters = parentClosingTags.length - topClosedParentIndex;
      for (let _ = 0; _ < numIters; _++) {
        const elInfo = parentClosingTags.pop()!;
        // Add this parentElement now, since we finally know what the fullLen is (there are no more children to iterate through)
        docNodes.set(elInfo.el, {
          stringPos: elInfo.index,
          stringLen: elInfo.length,
          parentList: getNodeParents(elInfo.el, topEl ?? containerEl),
          isEl: true,
          startTagLen: elInfo.startingTag.length,
        });
        const closingStr = elInfo.closingTag;
        stringIndex += closingStr.length;
        constructedHTMLString += closingStr;
      }
    }

    if (node instanceof Element) {
      // Find the length of the opening and closing tag of this element
      const [startingTag, closingTag] = getElementString(node);
      const index = stringIndex;
      // Note that we are using startingTag.length, not nodeStr.length. That is because all the children
      //  of this element are systematically going to be explored after this and added to the index/string.
      // Using nodeStr would be double counting them. The only thing unique to an element- that won't be
      //  considered- later is the startingTag and endTag e.g. <p style="margin:0;display:block;">  and </p>
      stringIndex += startingTag.length;
      constructedHTMLString += startingTag;
      const length = startingTag.length + (closingTag?.length ?? 0);

      parentClosingTags.forEach((parentInfo) => (parentInfo.length += length));

      if (closingTag !== null) {
        parentClosingTags.push({
          el: node,
          startingTag,
          closingTag,
          length,
          index,
        });
      } else {
        // If this is a void element, then we know what the full length is already and should set its docNdoes entry now
        docNodes.set(node, {
          stringPos: index,
          stringLen: length,
          parentList: getNodeParents(node, topEl ?? containerEl),
          isEl: true,
          startTagLen: startingTag.length,
        });
      }
    } else {
      docNodes.set(node, {
        stringPos: stringIndex,
        stringLen: nodeStr.length,
        parentList: getNodeParents(node, topEl ?? containerEl),
        isEl: false,
      });
      parentClosingTags.forEach(
        (parentInfo) => (parentInfo.length += nodeStr.length),
      );
      stringIndex += nodeStr.length;
      constructedHTMLString += nodeStr;
    }
  }
  // Any elements that were not yet processed because they didn't have next siblings, are processed now
  while (parentClosingTags.length > 0) {
    const elInfo = parentClosingTags.pop()!;
    const closingStr = elInfo.closingTag;
    docNodes.set(elInfo.el, {
      stringPos: elInfo.index,
      stringLen: elInfo.length,
      parentList: getNodeParents(elInfo.el, topEl ?? containerEl),
      isEl: true,
      startTagLen: elInfo.startingTag.length,
    });
    stringIndex += closingStr.length;
    constructedHTMLString += closingStr;
  }
  return [docNodes, constructedHTMLString];
}

function getNodeParents(node: Node, topEl: Element): Element[] {
  if (node === topEl || !topEl.contains(node)) return [];

  let parent = node.parentElement;
  const allParents: Element[] = [];

  while (parent && parent !== topEl) {
    allParents.push(parent);
    parent = parent.parentElement;
  }
  return allParents;
}
/**
 * Removed node and all its children, grandchildren, etc. (its entire subtree) from nodeLocs
 */
function removeNodeSubtree(nodeLocs: DocNodeMap, node: Node) {
  nodeLocs.delete(node);
  node.childNodes.forEach((node) => removeNodeSubtree(nodeLocs, node));
}

function shiftIndexes(
  nodeLocs: DocNodeMap,
  shiftIndex: number,
  shiftOffset: number,
  avoidNode: Node | Node[] | null,
  debug?: { oldVal: string; newVal: string },
) {
  let count = 0;
  const updatedNodes: Node[] = [];
  nodeLocs.entries().forEach(([el, info]) => {
    if (Array.isArray(avoidNode) ? closest(el, avoidNode[0]) : el === avoidNode)
      return;
    if (info.stringPos >= shiftIndex) {
      info.stringPos += shiftOffset;
      count++;
      updatedNodes.push(el);
    }
  });

  if (debug)
    console.log(
      `ðŸ’ŸðŸ’ŸðŸ’Ÿ Updated the indexes of ${count} nodes (past the index of ${shiftIndex}) by offset ${shiftOffset}.
This was augmenting the string "${debug.oldVal}" -> "${debug.newVal}"`,
      updatedNodes,
    );
}
function shiftParentLens(
  nodeLocs: DocNodeMap,
  node: Node,
  offset: number,
  parentsList?: Element[] | null,
  debug?: { oldVal: string; newVal: string },
) {
  let count;
  let updatedParents: Node[] = [];

  if (!parentsList) {
    let parent = node.parentElement;
    if (!parent) return;
    let parentInfo = nodeLocs.get(parent);
    count = 0;
    while (parentInfo) {
      parentInfo.stringLen += offset;
      count++;
      updatedParents.push(parent);

      parent = parent?.parentElement ?? null;
      if (!parent) break;
      parentInfo = nodeLocs.get(parent);
    }
  } else {
    count = parentsList.length;
    updatedParents = parentsList;
    parentsList.forEach((parent) => {
      const parentInfo = nodeLocs.get(parent);
      if (!parentInfo) return;
      parentInfo.stringLen += offset;
    });
  }

  if (debug)
    console.log(
      `ðŸ’ŸðŸ’Ÿ Updated ${count} parents of`,
      node,
      `by the offset ${offset}. This was augmenting the string
"${debug.oldVal}" -> "${debug.newVal}"`,
      updatedParents,
    );
}

export function handleMutationRecordPatch(
  record: MutationRecord,
  nodeLocs: DocNodeMap,
  containerEl: Element,
  totalAdded?: Node[],
  debug?: {
    htmlStr?: string;
    startIndexLog?: boolean;
    attributeChange?: boolean;
    characterDataChange?: boolean;
  },
): DocPatch[] {
  const getStartIndex = (node: Node, debug?: boolean): number => {
    const prev = prevSibling(node);
    const nodeInfo = prev ? nodeLocs.get(prev) : null;

    if (debug) console.log("Previous sibling info: ", prev, nodeInfo);

    if (prev && !nodeInfo)
      throw new Error(
        "When finding start index for adding/removing nodes, encountered a previous sibling node which was not found in nodeLocs.",
      );

    if (nodeInfo) {
      return nodeInfo.stringPos + nodeInfo.stringLen;
    } else {
      // node.parentNode may also return a Document or DocumentFragment object, whereas node.parentElement
      //  only returns Element objects. It makes no difference here, as everything is done under docEl (an Element)
      const parent = node.parentElement!;
      const nodeInfo = nodeLocs.get(parent);
      if (debug)
        console.log("No previous sibling. Parent info:", parent, nodeInfo);
      // Assume then that the parent is the top-level container docEl, thus the start index is 0
      //  (this is the first child of the top-level container docEL)
      if (!nodeInfo) return 0;
      if (nodeInfo.isEl) return nodeInfo.stringPos + nodeInfo.startTagLen;
      // Guaranteed to be an element- the parent has children (this node) which only elements can have
      //  Therefore this code will never be reached, but is here to make TypeScript happy
      return -1;
    }
  };

  if (
    debug?.htmlStr ||
    debug?.startIndexLog ||
    debug?.attributeChange ||
    debug?.characterDataChange
  )
    console.log(`%cHandling ${record.type} mutation.`, "font-size: x-large");

  const target = record.target;
  const nodeStr = getNodeSourceRepresentation(target);
  const nodeInfo = nodeLocs.get(target);

  if (
    target instanceof HTMLElement &&
    target.classList.contains("potential-location")
  )
    return [];

  let value: string;
  switch (record.type) {
    case "attributes":
      // Assuming that only elements can have attributes, which seems correct
      const el = target as Element;
      [value] = getElementString(el);

      if (debug?.attributeChange)
        console.log(
          `${record.attributeName}: "${record.oldValue}" -> "${el.getAttribute(record.attributeName ?? "")}"`,
        );
      break;
    case "characterData":
      value = nodeStr;

      if (debug?.characterDataChange)
        console.log(`"${record.oldValue}" -> "${target.textContent}"`);
      break;
    case "childList":
      const patches: DocPatch[] = [];

      // getStartIndex uses the previous sibling of the element to find its position in the string.
      //  That means, the previous element needs to already have been processed and be inside nodeLocs.
      //  If in the addedNodes list we process nodes in not an ascending DOM tree order, then we risk
      //  requiring an added node's string index before it has been calculated, and thus we sort the addedNodes
      //  (and removedNodes) list to make sure that doesn't happen.
      // However, I believe it might be unnecessary. Nodes in the addedNodes and removedNodes lists are
      //  guaranteed to be contiguous, because the only ways to get a list greater than 1 is appending
      //  a DocumentFragment, or directly altering a HTML string. All elements in a DocumentFragment are
      //  guaranteed to be contiguous, and so is altering a HTML string, which removes *all* the nodes in a container
      //  and then adds *all* the nodes of the new HTML string- both lists are always contiguous.
      //  Furthermore, I believe these two scenarious also always have the lists already processed in ascending DOM tree order.
      //  But, just to be safe, these calls are still here.
      for (const added of sortNodesInDocumentOrder(record.addedNodes)) {
        // Ignore if we've already added this node. This can happen when a parent of this
        //  node is added first, then this node is explicitly added after (the parent node
        //  is fully up-to-date with the current *actual* state of the DOM when processed, and thus
        //  will already have its children attached).
        if (nodeLocs.has(added)) continue;
        if (
          added instanceof HTMLElement &&
          added.classList.contains("potential-location")
        )
          continue;
        if (added.parentElement?.classList?.contains("potential-location"))
          continue;

        const index = getStartIndex(added, debug?.startIndexLog);
        // console.log("Final determined index: ", index);
        // console.log("------");
        let value: string;
        if (added instanceof Element) {
          [, value] = reconstructHTMLStr(
            added,
            true,
            index,
            nodeLocs,
            containerEl,
          );
        } else {
          value = getNodeSourceRepresentation(added);
          nodeLocs.set(added, {
            stringPos: index,
            stringLen: value.length,
            parentList: getNodeParents(added, containerEl),
            isEl: false,
          });
        }

        const shiftDebug = debug ? { oldVal: "", newVal: value } : undefined;
        shiftParentLens(nodeLocs, added, value.length, null, shiftDebug);
        // At this point we've already included added in nodeLocs, so we have to make sure
        //  it isn't also index shifted. Likely, the index where we're adding this node
        //  is already the start index of a different node, and that does need to be shifted
        //  (essentially, the new node is bullying the old node out of its old position).
        //  Hence, why the check is "greater than OR EQUAL TO index" .
        shiftIndexes(nodeLocs, index, value.length, [added], shiftDebug);

        const patch = {
          value,
          start: index,
          length: 0,
        };
        patches.push(patch);
      }

      // Fun fact, removed nodes are already disconnected from the DOM when we process them.
      //  (Good thing every single node is included in the nodeLocs mapping).
      for (const removed of sortNodesInDocumentOrder(record.removedNodes)) {
        // Ignore if we've already removed this node. This can happen when a parent of this
        //  element is removed first, then this element is also explicitly removed after
        if (!nodeLocs.has(removed)) continue;
        if (
          removed instanceof HTMLElement &&
          removed.classList.contains("potential-location")
        )
          continue;
        if (removed.parentElement?.classList?.contains("potential-location"))
          continue;

        const nodeInfo = nodeLocs.get(removed)!;
        const index = nodeInfo.stringPos;

        removeNodeSubtree(nodeLocs, removed);

        const shiftDebug =
          debug && debug.htmlStr
            ? {
                oldVal: debug.htmlStr.slice(
                  nodeInfo.stringPos,
                  nodeInfo.stringPos + nodeInfo.stringLen,
                ),
                newVal: "",
              }
            : undefined;

        // Because this node is disconnected, it doesn't have any parents... dangit
        shiftParentLens(
          nodeLocs,
          removed,
          -nodeInfo.stringLen,
          nodeInfo.parentList,
          shiftDebug,
        );
        shiftIndexes(nodeLocs, index, -nodeInfo.stringLen, null, shiftDebug);

        const patch = {
          value: "",
          start: index,
          length: nodeInfo.stringLen,
        };
        // console.log(patch);
        patches.push(patch);
      }
      return patches;
  }

  // Is there a valid fail case where the observer tries to update something about an element
  //  which has an earlier record this callback which removed it?
  if (!nodeInfo) {
    console.error(target);
    // throw new Error(
    //   `In mutation of type "${record.type}", the target was not found in nodeLocs.`,
    // );
    console.error(
      `In mutation of type "${record.type}", the target was not found in nodeLocs.`,
    );
    return [];
  }

  // Don't modify info for nodes that were just added in this mutation callback, as what is added
  //  is already fully up-to-date. This should hopefully save resources, but is otherwise not required functionality.
  if (totalAdded && totalAdded.includes(target)) return [];

  const oldLen = nodeInfo.isEl ? nodeInfo.startTagLen : nodeInfo.stringLen;
  const lenDiff = value.length - oldLen;

  nodeInfo.stringLen += lenDiff;
  if (nodeInfo.isEl) nodeInfo.startTagLen = value.length;

  const shiftDebug =
    debug && debug.htmlStr
      ? {
          oldVal: debug.htmlStr.slice(
            nodeInfo.stringPos,
            nodeInfo.stringPos + oldLen,
          ),
          newVal: value,
        }
      : undefined;

  shiftParentLens(nodeLocs, target, lenDiff, null, shiftDebug);
  // prettier-ignore
  shiftIndexes(nodeLocs, nodeInfo.stringPos, lenDiff, target, shiftDebug);

  return [
    {
      value,
      start: nodeInfo.stringPos,
      length: oldLen,
    },
  ];
}

export function applyPatches(docStr: string, patches: DocPatch[]) {
  // debugger;
  for (const patch of patches) {
    debugger;
    docStr =
      docStr.slice(0, patch.start) +
      patch.value +
      docStr.slice(patch.start + patch.length);
  }
  return docStr;
}

let prevFetch: Promise<Response> | null = null;

export function patchMutations(
  mutations: MutationRecord[],
  docNodes: DocNodeMap,
  containerEl: Element,
  documentID: number,
  opts: {
    updateHTMLStr?: string;
    debug?: boolean;
    useIgnoreAddedNodeMutations?: boolean;
  } = {},
) {
  const totalAdded: Node[] | undefined = opts.useIgnoreAddedNodeMutations
    ? []
    : undefined;
  let newHTMLStr: string = opts.updateHTMLStr ?? "";
  // if (opts.debug && opts.updateHTMLStr !== undefined) {
  //   console.log("%cOriginal HTML string", "font-size: x-large; color: yellow");
  //   console.log(opts.updateHTMLStr);
  // }

  const patches: DocPatch[] = [];
  for (const mutation of mutations) {
    // Change code if you want startIndexLog, attributeChange and/or characterDataChange
    // Note, for attributeChange requires "attributeOldValue: true" in observer options, and
    //           characterDataChange requires "characterDataOldValue: true" in observer options.
    const newPatches = handleMutationRecordPatch(
      mutation,
      docNodes,
      containerEl,
      totalAdded,
      {
        htmlStr:
          opts.debug && opts.updateHTMLStr !== undefined
            ? newHTMLStr
            : undefined,
        startIndexLog: opts.debug ? false : false,
        attributeChange: opts.debug ? false : false,
        characterDataChange: opts.debug ? false : false,
      },
    );

    if (totalAdded) totalAdded.push(...mutation.addedNodes);
    if (opts.updateHTMLStr !== undefined)
      newHTMLStr = applyPatches(newHTMLStr, newPatches);
    if (opts.debug) {
      // console.log(newPatches);
      // if (opts.updateHTMLStr !== undefined) console.log(newHTMLStr);
    }
    patches.push(...newPatches);
  }

  const createFetch = () =>
    fetch_("/documents/sync_document_patch", {
      method: "post",
      body: JSON.stringify({
        id: documentID,
        patches: patches.map((patch) => {
          return {
            index: patch.start,
            length: patch.length,
            value: patch.value,
          };
        }),
      }),
    });
  if (patches.length > 0) {
    if (prevFetch === null) prevFetch = createFetch();
    else prevFetch = prevFetch.then(createFetch);
  }

  if (opts.debug) {
    console.log("ðŸ’œðŸ’œðŸ’œ Patch sync");
    console.log(patches);
    console.log(docNodes);
    if (opts.updateHTMLStr !== undefined && patches.length > 0)
      console.log(newHTMLStr);
    console.log("\n------------------------\n");
  }

  return opts.updateHTMLStr ? newHTMLStr : "";
}
