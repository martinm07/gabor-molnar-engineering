import { Map, Set } from "immutable";
import { splitStringAtChar } from "./handlecss";
import { isInputEvent } from "../../helper";

interface ElementStateManagerOptions {
  gcInterval?: number;
  autoGC?: boolean;
}

// Generated by Claude
class ElementStateManager<V> {
  stateMap: Map<Set<Element>, V>;
  _gcIntervalId: NodeJS.Timeout | null = null;
  gcInterval: number;
  autoGC: boolean;

  constructor(options: ElementStateManagerOptions = {}) {
    this.stateMap = Map();
    this.gcInterval = options.gcInterval || 30000; // Default GC interval: 30 seconds
    this.autoGC = options.autoGC !== false; // Enable auto GC by default

    // Start automatic garbage collection if enabled
    if (this.autoGC) {
      this.startAutoGC();
    }
  }

  setState(elements: Element[], state: V) {
    // Convert array or regular Set to Immutable Set
    const elementSet = Set(elements);
    this.stateMap = this.stateMap.set(elementSet, state);
  }

  getState(elements: Element[]) {
    const elementSet = Set(elements);
    return this.stateMap.get(elementSet);
  }

  hasState(elements: Element[]) {
    const elementSet = Set(elements);
    return this.stateMap.has(elementSet);
  }

  deleteState(elements: Element[]) {
    const elementSet = Set(elements);
    this.stateMap = this.stateMap.delete(elementSet);
  }

  // Get all stored element sets that match a predicate
  findElementSets(predicateFn: (els: Set<Element>) => boolean) {
    return this.stateMap
      .keySeq()
      .filter((elementSet) => predicateFn(elementSet))
      .toArray();
  }

  get size() {
    return this.stateMap.size;
  }

  // Check if an Element is still in the DOM
  isElementConnected(element: Element) {
    return element && element.isConnected !== false;
  }

  // Check if all Elements in a set are still connected to the DOM
  areElementsConnected(elementSet: Set<Element>) {
    return elementSet.every((element) => this.isElementConnected(element));
  }

  // Garbage collection - remove entries with disconnected elements
  garbageCollect() {
    const beforeSize = this.stateMap.size;

    // Filter out entries where any Element is disconnected
    this.stateMap = this.stateMap.filter((_, elementSet) =>
      this.areElementsConnected(elementSet),
    );

    const removedCount = beforeSize - this.stateMap.size;
    if (removedCount > 0) {
      console.debug(
        `ElementStateManager: Garbage collected ${removedCount} entries`,
      );
    }

    return removedCount;
  }

  // Start automatic garbage collection
  startAutoGC() {
    this.stopAutoGC(); // Clear any existing interval
    this._gcIntervalId = setInterval(
      () => this.garbageCollect(),
      this.gcInterval,
    );
  }

  // Stop automatic garbage collection
  stopAutoGC() {
    if (this._gcIntervalId) {
      clearInterval(this._gcIntervalId);
      this._gcIntervalId = null;
    }
  }

  // Clean up when the manager is no longer needed
  dispose() {
    this.stopAutoGC();
    this.stateMap = this.stateMap.clear();
  }

  // Force immediate garbage collection and get statistics
  forceGC() {
    const beforeSize = this.stateMap.size;
    const removedCount = this.garbageCollect();
    const afterSize = this.stateMap.size;

    return {
      beforeCount: beforeSize,
      removedCount: removedCount,
      remainingCount: afterSize,
    };
  }
}

// Usage
// const manager = new ElementStateManager();

// // Add some elements and state
// const div1 = document.createElement("div");
// const div2 = document.createElement("div");
// const div3 = document.createElement("div");

// manager.setState([div1, div2], { name: "Group 1" });

// // Later retrieval - will find the state even with new Set instance
// // that contains the same Element objects
// const sameElements = [div1, div2];
// console.log(manager.getState(sameElements)); // { name: "Group 1" }

// // Different elements = different key
// const differentElements = [div2, div3];
// console.log(manager.getState(differentElements)); // undefined

// console.log("ðŸŽˆðŸŽˆðŸŽˆ");
// ///////////////////

export interface StyleStrSelection {
  isCollapsed: boolean;
  anchorIndex: number;
  focusIndex: number;
  direction: "backward" | "forward" | "none";
  focusLoc: "prop" | "val" | "other";
}

export interface CSSEditorState {
  text: string;
  selection: StyleStrSelection | null;
  insertType: "insert" | "delete" | "other";
}

interface UndoManagerOptions extends ElementStateManagerOptions {
  maxGroupTime?: number;
  maxItems?: number;
}

/**
 * Manages undo and redo history for CSS editor states associated with different element selections.
 *
 * The `UndoManager` tracks editing history for each selection of elements, allowing undo/redo operations
 * and grouping of edits based on timing and input type. It maintains a stack of editor states for each
 * selection, supports grouping edits within a configurable time window, and handles selection changes
 * by saving and restoring the corresponding history.
 *
 * @template CSSEditorState - The type representing the state of the CSS editor.
 * @template Element - The type representing an editable element.
 * @template StyleStrSelection - The type representing the selection within the editor.
 *
 * @remarks
 * - Uses an `ElementStateManager` to map selections to their respective undo/redo stacks.
 * - Supports grouping of edits to allow multiple rapid changes to be undone/redone as a single action.
 * - Handles selection changes by persisting and restoring the undo/redo stack for each selection.
 *
 * @example
 * ```typescript
 * const undoManager = new UndoManager({ maxGroupTime: 1000 });
 * undoManager.changeSelection([element], initialState);
 * undoManager.addEdit(newState, inputEvent);
 * undoManager.undo();
 * undoManager.redo();
 * ```
 *
 * @param opts - Configuration options for the undo manager, including grouping time and garbage collection.
 */
export class UndoManager {
  selectionHistMap: ElementStateManager<{
    stack: CSSEditorState[];
    index: number;
  }>;
  currentSelection: Element[] | null = null;
  stateHist: CSSEditorState[] = [];
  currentStackIndex: number = 0;

  maxGroupTime: number;
  isGrouping: boolean = true;
  groupTimeout: NodeJS.Timeout | null = null;

  maxItems: number;

  constructor(opts: UndoManagerOptions = {}) {
    this.maxGroupTime = opts.maxGroupTime ?? 1000;
    this.maxItems = opts.maxItems ?? -1;
    this.selectionHistMap = new ElementStateManager({
      gcInterval: opts.gcInterval,
      autoGC: opts.autoGC,
    });
  }

  changeSelection(newSelection: Element[], startState: CSSEditorState) {
    // Update the map with the editor state for this selection before changing to the next one
    // May create some troubles if we want to save edit history as persistent browser state
    if (this.currentSelection)
      this.selectionHistMap.setState(this.currentSelection, {
        stack: this.stateHist,
        index: this.currentStackIndex,
      });

    if (this.selectionHistMap.hasState(newSelection)) {
      const { stack, index } = this.selectionHistMap.getState(newSelection)!;
      this.stateHist = stack;
      this.currentStackIndex = index;
    } else {
      this.selectionHistMap.setState(newSelection, {
        stack: [startState],
        index: 0,
      });
      this.stateHist = [startState];
      this.currentStackIndex = 0;
    }
    this.currentSelection = newSelection;
  }

  isTrueEdit(newState: CSSEditorState): boolean {
    return newState.text !== this.stateHist[this.currentStackIndex].text;
  }

  addEdit(newState: CSSEditorState, event: InputEvent | Event) {
    // If this new state doesn't actually change the text then we ignore it; most importantly not removing
    //  redo history when restoring state from undoing causes input events itself
    if (!this.isTrueEdit(newState)) return;

    // Remove redo history when an edit occurs
    this.stateHist.splice(0, this.currentStackIndex);

    // Determine if this edit should be grouped with the last one or not
    const isGrouping = this.determineGrouping(newState, event);
    if (isGrouping) {
      this.stateHist[0] = newState;
    } else {
      this.stateHist.unshift(newState);
    }
    this.currentStackIndex = 0;

    if (this.maxGroupTime !== -1) {
      if (this.groupTimeout !== null) clearTimeout(this.groupTimeout);
      this.isGrouping = true;
      this.groupTimeout = setTimeout(
        () => (this.isGrouping = false),
        this.maxGroupTime,
      );
    }
    if (this.maxItems !== -1 && this.stateHist.length > this.maxItems) {
      this.stateHist.splice(this.maxItems);
    }
  }

  updateLatestStateSelection(newSelection: StyleStrSelection) {
    const state = this.stateHist[0];
    state.selection = newSelection;
  }
  updatePrevStateSelection(newSelection: StyleStrSelection) {
    const state = this.stateHist[1];
    state.selection = newSelection;
  }

  private determineGrouping(
    newState: CSSEditorState,
    event: InputEvent | Event,
  ): boolean {
    // We do group if this input doesn't actually change the content string (e.g. entering space in property field)
    // Not necessary if we're already checking in the addEdit() method
    // if (newState.text === this.stateHist[0].text) return true;

    // Do not allow grouping into the initial state
    if (this.stateHist.length <= 1) return false;
    // Do not group if we missed the time window
    if (!this.isGrouping) return false;

    // Do not group if we change from editing e.g. a property into editing a value in the CSS editor
    //  (for a proxy of this, we use the location of the selection focus point)
    //  (using the selection would fail if the edit changed multiple locations of the CSS editor at once.
    //   These edits should never be grouped and that should be handled by further checks.
    //   Could- however- add an extra check for if the edit involved more than a single character change. That should to be considered more though)
    if (
      newState.selection &&
      newState.selection.focusLoc !== this.stateHist[0].selection?.focusLoc
    )
      return false;

    // Do not group if event is a paste or other ("insertFromYank", "insertFromDrop", "insertFromPaste", "insertFromPasteAsQuotation")
    if (isInputEvent(event) && event.inputType.startsWith("insertFrom"))
      return false;

    // Do not group if edit is also not an insert nor delete
    //  (leaving- from the spec- format types like "formatJustifyCenter" or "formatBold" and "historyUndo" and "historyRedo")
    if (newState.insertType === "other") return false;

    // Do not group if edit type was "insert" and is now "delete", or vice-versa (changing from inserting to deleting, and vice-versa)
    if (newState.insertType !== this.stateHist[0].insertType) return false;

    console.log(`Will group edit. Last state is "${this.stateHist[1].text}"`);
    return true;
    // return true;
  }

  // Must be called before addEdit() which would add a state past the initial state
  updateInitialStateSelection(newSelection: StyleStrSelection | null) {
    if (newSelection === null || this.stateHist.length !== 1) return;
    this.stateHist[0].selection = newSelection;
  }

  undo(): CSSEditorState | null {
    if (this.currentStackIndex + 1 >= this.stateHist.length) return null;
    this.currentStackIndex += 1;
    return this.stateHist[this.currentStackIndex];
  }

  redo(): CSSEditorState | null {
    if (this.currentStackIndex <= 0) return null;
    this.currentStackIndex -= 1;
    return this.stateHist[this.currentStackIndex];
  }
}
